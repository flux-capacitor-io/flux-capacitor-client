/*
 * Copyright (c) Flux Capacitor IP B.V. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.fluxcapacitor.javaclient.web;

import lombok.AccessLevel;
import lombok.Getter;
import lombok.Value;

import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Represents a pattern used to match incoming {@link WebRequest}s to handler methods.
 * <p>
 * A {@code WebPattern} is created for each handler method meta-annotated with {@code @HandleWeb} and encapsulates a URI
 * pattern and HTTP method used to route requests.
 * <p>
 * The URI is parsed and dissected into components using a regular expression. This enables precise matching against
 * request paths, origins, and other elements of the URI structure.
 *
 * <h2>URI Parsing</h2>
 * The underlying URI parsing follows the general URI syntax as defined in
 * <a href="https://tools.ietf.org/html/rfc3986">RFC 3986</a>. Specifically:
 * <ul>
 *     <li>{@code path} – The relative or absolute path (e.g., {@code /users/{id}})</li>
 *     <li>{@code origin} – The full origin (e.g., {@code https://example.com}) including scheme and authority</li>
 * </ul>
 *
 * <p>Instances of {@code WebPattern} are typically generated by the framework and not manually constructed.
 * However, understanding this structure is useful when inspecting or customizing request dispatch behavior.
 *
 * @see WebRequest
 * @see HandleWeb
 * @see io.fluxcapacitor.javaclient.web.WebUtils#getWebPatterns(java.lang.reflect.Executable)
 */
@Value
public class WebPattern {

    /**
     * Regular expression used to extract URI components: scheme, authority, path, query, and fragment.
     */
    static final Pattern uriPattern = Pattern.compile("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?");

    /**
     * Parses a URI string into a {@link Matcher}, using the internal {@link #uriPattern}.
     *
     * @param uriString the URI string to parse
     * @return a matcher with access to groups like scheme, authority, and path
     * @throws IllegalStateException if the URI is malformed and doesn't match the expected pattern
     */
    static Matcher uriMatcher(String uriString) {
        Matcher result = uriPattern.matcher(Optional.ofNullable(uriString).orElse(""));
        if (result.matches()) {
            return result;
        }
        throw new IllegalStateException("Malformed URI: '" + uriString + "'");
    }

    /**
     * The URI pattern used to match the request's path and origin. This may include path variables or wildcard
     * segments.
     */
    String uri;

    /**
     * The HTTP method (e.g., {@code GET}, {@code POST}, {@code PUT}) this pattern matches against.
     */
    String method;

    /**
     * Lazily parsed path portion of the URI.
     * <p>
     * This value is guaranteed to start with {@code /}, unless the original URI was blank or missing a path.
     */
    @Getter(lazy = true)
    String path = Optional.ofNullable(getMatcher().group(5))
            .map(p -> p.startsWith("/") ? p : p.isBlank() ? "" : "/" + p).orElse("");

    /**
     * Lazily resolved origin from the URI, including scheme and authority (e.g., {@code https://example.com}).
     */
    @Getter(lazy = true)
    String origin = Optional.ofNullable(getMatcher().group(1))
            .map(scheme -> scheme + getMatcher().group(3)).orElse(null);

    @Getter(lazy = true, value = AccessLevel.PRIVATE)
    Matcher matcher = uriMatcher(uri);
}
