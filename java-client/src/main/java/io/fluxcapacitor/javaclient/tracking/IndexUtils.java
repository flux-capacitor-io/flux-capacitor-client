/*
 * Copyright (c) Flux Capacitor IP B.V. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.fluxcapacitor.javaclient.tracking;

import io.fluxcapacitor.javaclient.FluxCapacitor;

import java.time.Instant;

/**
 * Use 48 bits of the current time in milliseconds since epoch as the base of the index. The remaining 16 bits (65k) are
 * used to increment the index if messages are written in the same ms as the last batch.
 * <p>
 * The index is only able to store 2^47 - 1 ms of time since epoch, i.e. about 4,500 years.
 * <p>
 * Uses {@link FluxCapacitor#currentClock()} to get the index corresponding to the current timestamp of Flux Capacitor's
 * internal clock.
 */
public class IndexUtils {

    /**
     * Extracts the millisecond component from the given index value.
     *
     * @param index The input index value, where the higher 48 bits represent the milliseconds since the epoch, and the
     *              lower 16 bits are used for incrementing within the same millisecond.
     * @return The number of milliseconds since the epoch, derived from the given index.
     */
    public static long millisFromIndex(long index) {
        return index >> 16;
    }

    /**
     * Converts the given index to a timestamp.
     * <p>
     * The method interprets the index as a value where the upper 48 bits represent milliseconds since the epoch.
     *
     * @param index the index to convert, where the upper 48 bits represent milliseconds since epoch
     * @return an {@code Instant} representing the timestamp corresponding to the provided index
     */
    public static Instant timestampFromIndex(long index) {
        return Instant.ofEpochMilli(millisFromIndex(index));
    }

    /**
     * Computes an index based on the provided timestamp. The index is generated by converting the timestamp to
     * milliseconds since the Unix epoch and shifting it to allocate 48 bits for storing the timestamp with additional
     * 16 bits reserved for increments within the same millisecond.
     *
     * @param timestamp the Instant object representing a specific timestamp
     * @return the computed index as a long value, based on the provided timestamp
     */
    public static long indexFromTimestamp(Instant timestamp) {
        return indexFromMillis(timestamp.toEpochMilli());
    }

    /**
     * Derives an index value from the given timestamp in milliseconds since the epoch by shifting it 16 bits to the
     * left. This method is used for generating a unique index value with additional room for handling increments within
     * the same millisecond.
     *
     * @param millisSinceEpoch the timestamp in milliseconds since the epoch
     * @return the computed index value derived from the given timestamp
     */
    public static long indexFromMillis(long millisSinceEpoch) {
        return millisSinceEpoch << 16;
    }

    /**
     * Computes the maximum possible index for the given timestamp in milliseconds since the epoch.
     * <p>
     * The index is calculated by shifting the given milliseconds since epoch by 16 bits to the left and subsequently
     * adding 65,535 to determine the upper limit for that millisecond.
     *
     * @param millisSinceEpoch the time in milliseconds since the epoch (January 1, 1970, 00:00:00 GMT)
     * @return the maximum index corresponding to the provided time in the Flux Capacitor index space
     */
    public static long maxIndexFromMillis(long millisSinceEpoch) {
        return indexFromMillis(millisSinceEpoch) + 65_536 - 1;
    }

    /**
     * Calculates the offset from the given index by extracting the least significant 16 bits.
     *
     * @param index the index from which the offset will be derived, typically a value combining time-based and
     *              incremental components
     * @return the offset, which is an integer in the range 0 to 65,535
     */
    public static int offsetFromIndex(long index) {
        return (int) (index % 65_536);
    }

    /**
     * Calculates an index based on the current timestamp from Flux Capacitor's internal clock. The method uses the
     * current time in milliseconds since the epoch, shifted left by 16 bits.
     *
     * @return a 64-bit long value representing the calculated index. The upper 48 bits represent the current time in
     * milliseconds since the epoch, and the lower 16 bits are reserved for potential incrementation within the same
     * millisecond.
     */
    public static long indexForCurrentTime() {
        return FluxCapacitor.currentClock().millis() << 16;
    }

    /**
     * Generates the next unique index based on the current time or the last provided index.
     *
     * @param lastIndex The last index that was generated. Can be null. If null, the method generates an index based on
     *                  the current time.
     * @return The next index, which is either based on the current time or incremented from the provided last index.
     */
    public static long nextIndex(Long lastIndex) {
        return lastIndex == null ? indexForCurrentTime() : Math.max(indexForCurrentTime(), lastIndex + 1L);
    }
}
